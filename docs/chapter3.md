# 第3章：基础语法入门

NPC++ 的语法设计基于标准C 语言，大大降低了开发者的学习门槛。但作为一门面向硬件的数据面编程语言，它在类型系统、位宽控制和副作用管理上有着比通用语言更严格的约束。本章将系统地介绍其基础语法体系。

## 3.1 基础语法

NPC++ 程序由一系列预处理指令、类型定义和功能模块组成。与 C 语言类似，它要求必须编译完整的程序单元。

### **3.1.1 预处理与文件包含**

代码通常以预处理指令开头。NPC++ 支持标准的 C/C++ 预处理机制，包括宏定义（`#define`）和条件编译（`#ifdef`）。最重要的是`#include` 指令，它用于引入用户自定义的头文件（如 "user_def.h"）。一旦头文件被包含，其中定义的常量、结构体和函数即可在当前源文件的全局范围内使用，这是实现代码模块化管理的基础。

```cpp
//如需要预处理，则将下述内容放在代码头部
#define
#undef
#if / #else / #endif / #ifdef
#include<文件名>
#include"文件名"
```

### **3.1.2 标识符**

1. 所有的NPC++关键字都只使用ASCII字符，区分大小写。
2. 与C语言命名规则一样，标识符只能包含字母、数字和下划线符号_，并且必须以字母或下划线开头。**编译器将以’_’开头的标识符的命名空间用于预定义字段或内置函数。用户不要使用此命名方式**。

编译器可以识别以下类型的标识符：

- IDENTIFIER –名字，以字母或下划线开头，包含字母、数字和下划线，例如 Test、tmp_A、Li_1
- TYPE – 表示类型名称的标识符，例如 enum、struct
- INTEGER – 整型，例如 uint<4> a=8
- 关键字，例如return。语言关键字使用小写拼写。

### **3.1.3 注释**

注释为C++样式：

- 单行注释，通过`//` 实现，作用到本行结尾
- 多行注释，括在`/*`和`*/`之间，作用于多行文本
- 不支持嵌套的多行注释

```cpp
// 单行注释1，到行尾结束
/* 多行注释2
   多行注释3...
*/
```

## 3.2 常量、变量与数据类型

### **3.2.1 常量**

**布尔常量**

编译器预定义了两个布尔常量：true和false，分别等同于1和0。

**整型常量**

整型常量是正整数。默认为十进制。要使用十六进制的常量，必须使用0x前缀：

- 无前缀表示基数为10
- 0x或0X表示基数为16

**Tips：**整数常量是无符号，需要通过uint<W>直接标识整数的位宽，W是正整数。

以下是整型常量的几个示例：

```cpp
123              //无符号值123，精度不确定
(uint<32>)0xFF  //值为255的32位无符号数，最好声明确定的位宽(本例子是32位宽)
(uint<8>)0xAA   //8位无符号数，值为0xAA
(uint<8>)170    //同上
```

### **3.2.2 变量**

可以使用与C/C++一样的方式定义局部变量：

对变量的类型没有限制：可以显示编写的大多数类型（例如  uint、struct、union）都可以使用。

Tips：由于枚举类型enum不具有宽度，因此枚举类型不能用作变量或struct/union成员的基本类型（即变量的声明必须声明位宽）。

**读取一个尚未初始化的变量的值会得到一个未定义的结果，编译器会检测并报告警。没有显示初始化的变量是未初始化的。**

变量定义可以出现在程序中的全局作用域、任何函数内：

全局变量需要在ControlFlow函数里进行初始化（章节2.2的第四个模块）

```cpp
//示例
uint<32> a; //全局变量
@control void ControlFlow()
{
		a=48;
    //其他数据面代码
}

```

### **3.2.3 作用域（功能体）**

各种程序模块充当作用域（解析模块@parser、表模块@table、控制流模块@control）类似C语言中的函数，声明的常量、变量只在当前作用域生效：

- 复合类型声明（struct、union）为成员名引入局部作用域
- @parser、@table和函数引入局部作用域

### **3.2.4 数据类型**

NPC++ 是一门强类型编程语言，其所有值均采用静态类型设计。因此，开发者需在编码初始阶段就明确声明所有变量的数据类型。Tips：可以通过使用强制转换转换为不同的类型，但可供选择的强转范围基本限制于整数。

**基本类型**

**void类型：**void类型写成void。它不包含任何值。它只能出现在NPC++程序中的少数受限的地方，比如函数声明返回类型。void类型主要用于保持与C/C++类型语法的兼容性。

**布尔类型：**编译器没有定义特殊的布尔类型。宽度为1位的无符号整数作为布尔基本类型。条件逻辑表达式计算结果为布尔类型。

示例：

```cpp
uint<8> a;
uint<1> cond;
if (a != 0)     //逻辑条件表达式
if (cond == 1)  //合法的
if (a)          //非法的，即大于1的位宽不是布尔类型，不能直接判断
```

**整数类型**

包括无符号和有符号两种类型

无符号整数具有任意宽度，以位表示。宽度为W的无符号整数声明为：uint<W>。W必须是为大于
0的正整数。

例如，类型uint<128>表示无符号整数值的类型，128位从0到127进行编号，其中127是最高位。

下表显示了整数类型的几个示例。

| 整数字面量 | 解读 |
| --- | --- |
| 10 | 未声明宽度，类型为无符号类型，值为10 |
| (uint<8>)10 | 类型为uint<8>，值为10 |
| (uint<10>)10 | 类型是uint<10>，值是10 |
| (uint<2>)3 | 类型为uint<2>，值为3（宽度只有2位） |
| (uint<1>)10 | 类型为uint<1>，值为0（宽度只有1位，最低位） |
| (int<1>)10 | 错误：1位有符号类型——非法 |
| (int<11>) 10 | 类型为int<4>，有符号，值为10 |

**复合类型**

可以在NPC++中从上述基本类型创建其他类型。一些复合类型可以由程序员显式地使用类型声明创建：

- enum
- struct/union
- typedef

**enum、struct/union和typedef只能在类型声明中使用，它们为类型引入了一个新的名称。随后可以使用此标识符引用类型。**

复合类型只能在全局作用域（即代码头部）中定义。

**枚举类型：**基于C的enum，但更受限制，使用以下语法定义：

```cpp
enum example_e { op1 = 5, op2, op3 };
```

每个枚举量（op1，op2，op3）都是一个全局常量，该常量表示枚举量的值。这些值的位宽没有指定，因此，枚举类型不能用作基本类型，只能是赋值给其他变量，例如。

```cpp
example_e my_example = op3; //非法的变量声明
uint<3> my_example = op3;   //具有宽度的变量声明
```

**`struct/union`类型：**类似于C的`struct/union`。包含所有的成员，成员可以由任何其他类型组成：基本类型或复合类型。与C中不同的是，枚举类型不能放在struct/union中。

struct/union一旦定义，宽度即是确定的。对于struct，它的宽度是所有成员的宽度之和，没有填充或对齐。

例如，定义一个典型的以太网协议头：

```cpp
struct Ethernet_S {    
  uint<48> dstAddr;    
  uint<48> srcAddr;   
  uint<16> etherType;
}
```

可以使用上述定义的struct类型的创建变量：

```cpp
//NPCHeader是NPC++语言里固定的结构体声明+初始化方式，类似于C语言里Ethernet_S ethernetHeader;
NPCHeader<Ethernet_S> ethernetHeader;
```

**自定义类型typedef**

**typedef可以用来为类型指定一个别名。**

```cpp
typedef uint<32> u32;
typedef struct Point { 
  uint<32> x; 
  uint<32> y; 
} Pt;
```

所有可以在原始类型上执行的操作也可以在新创建的类型上执行。类似于C typedef关键字。

## 3.3 表达式、语句与函数

介绍了可以在NPC++中执行的所有表达式，并按可以处理的值的类型分组。作为一般规则，表达式与C/C++语言表达式的语法和语义相匹配。在少数情况下，为了匹配给定特定目标架构的编程模型，需要某些限制。

### 3.3.1 表达式

**枚举表达式**

枚举声明的变量总是分配给全局命名空间，即全局变量：

```cpp
enum X { v1, v2=val, v3 }
```

**枚举值与整数常量相同，可以在任何可以使用常量的地方使用。**

可以为每个枚举的变量赋值，如果没赋值的变量，会在前面有值的变量基础上递增，最好为所有变量赋初值

Tips：如果第一个变量没有提供值，则其默认值为0。

            与整数常量类似，枚举标签可用于任何宽度的操作中。

```cpp
enum X { v1,          //v1得到的值为0 
         v2=12,       //v2得到的值是12
         v3           //v3得到的值是13
}
const uint<5> var = v2;     //var获得宽度为5位的值12
```

**布尔表达式**

对布尔或者位宽为1的整数变量提供以下操作：

- 与，使用 && 操作符
- 或，使用 || 操作符
- 非，使用 ！ 操作符
- 相等和不等，使用 == 和 != 操作符

优先级和C/C++类似，为保证正确，建议需要优先运算的加上括号

遵循求值短路，即一旦计算出结果就停止后续运算。

```cpp
uint<1> a=0;
uint<1> b=1;
if(a&&b) //结果为假
if(b||a) //结果为真，算完b即得出结果
if(!a) //结果为真
```

**无符号整数表达式**

所有二元操作（移位除外）要求两个操作数具有相同的宽度；提供不同宽度的操作数需要隐式或显式转换，并可能产生编译时错误。

对无符号整数提供以下操作：

- 测试相同宽度的无符号整数之间的相等性，用==表示。结果为布尔值。
- 测试相同宽度的无符号整数之间的不等性，用!=表示，结果为布尔值。
- 无符号比较<、>、<=、>=。两个操作数必须具有相同的宽度，结果为布尔值。

```cpp
uint<8> a=10;
uint<8> b=12;
uint<4> c=16;

if (a==b || a!=b || a>b || a<b || a<=b || a>=b) //条件表达式
```

以下所有操作在应用于无符号整数时都会产生无符号整数结果。所有这些操作都要求两个操作数具有相同的宽度。

- 加法，用+表示。
- 减法，用-表示。
- 两个相同宽度的无符号整数之间的按位”与”，用&指定
- 在两个相同宽度的无符号整数之间按位”或”，用|指定
- 取反，单个无符号整数的按位”补码”，用~表示
- 两个宽度相同的无符号整数的按位”异或”运算，用^表示
- 无符号整数的赋值，其中两个无符号整数的宽度完全相同。
- 赋值运算：用于赋值、加、减、按位或、按位与、按位异或。
- 进行逻辑左移和右移（左操作数是无符号的，右操作数必须是`uint<S>`类型的无符号数或非负常量整数），由<<和>>指定。结果与左操作数的类型相同。移位量大于输入宽度的移位会产生所有位为零的结果。

```cpp
uint<8> a=10;
uint<8> b=12;
uint<8> c;

c=a+b; c=a-b; c=a&b; c=a|b; c=~a; c=a^b;  //运算操作，如果运算的位宽超过了8，则截断，只保留8位

c=a<<2;
c=a>>4; //注意右移操作的所有变量必须确定位宽,即uint<W>
```

还有以下操作：

- 提取一组连续的位，用 [m:l] 表示，其中m和l是正整数， m >= l 。结果是一个宽度为 m-l+1 的无符号整数，包括从源操作数的l到m的位。静态检查条件 0 <= l < W 和 l <= m < W （W为源比特串的长度，即位宽）。请注意，提取的两个端点都是包含的。边界必须是恒定的，这样结果宽度必须在编译时计算。

```cpp
uint<8> a=10;
uint<8> b=12;

uint<4> c=a[6:3];  //即提取变量a里面的第3-6位的内容赋值给c 
```

**强制转换表达式**

NPC++支持的强制转换非常有限，仅限于整数类型，最好事先声明宽度。

强制转换表达式的写法与C一样

```cpp
uint<8> b;
b = (uint<8>)a;
```

**显式强制转换：**以下是所有合法的强制转换：

- **uint<1>与bool等价: 0为假，1为真。**
- **uint<W> 转换uint<X>：如果：如果W>X将导致截断，如果W<X将导致高位扩展将导致高位扩展0。**
- 一个`struct`可以被强制转换为另一个`struct` 。

**基于struct/union类型的表达式**

在具有`struct/union`类型的对象上定义的唯一操作是成员访问操作，使用点（“.”）运算符（例如，`s.field`）表示。`struct/union`也可以用于赋值，这仅在具有相同宽度的`struct/union`之间才可能进行。

### 3.3.2 语句

语句（块语句除外）必须以分号结束，与C/C++风格相同。

**赋值语句**

赋值用”=“符号表示。

赋值计算右侧的表达式，并将该值赋值到左侧。复合类型（例如struct）是递归赋值的。

示例：

```cpp
g_VlanAclEn[20:18]=0;   //全局变量域段赋值
rwDmac=Ether.Dmac;      //局部变量赋值
```

**非法赋值：**为了简化代码阅读，以及为了保持应用程序的可移植性，NPC++语言不允许任何有副作用的表达式。在NPC++中，以下都是非法的：

- 表达式中的赋值运算符
- 表达式中的后/前递增或后/前递减运算符
- 表达式内的函数/操作调用
- 逗号表达式

下面的例子都是在NPC++中非法的：

```cpp
a = b = c;
a = b, c;
a++ = b;
a = b++ * c;
```

**左值：**左值是可以出现在赋值操作左侧的表达式。这些表达式是合法的左值：

- 基类型或复合类型的变量
- struct成员访问操作（使用点表示法）
- 对NPCHeader即结构体中的元素的引用。
- 位切片运算符`[start:end]`的结果

以下是合法的左值：

```cpp
headers.field;
e[start:end] = x; 
/* 切片赋值的含义如下：
该语句将e的位start到end 设置为x表示的位模式，并保持e的所有其他位不变。
（x的宽度需要为start-end+1，或者应该显式地转换为start-end+1的无符号整数值）*/
```

**条件语句**

条件语句与C/C++的 if语句在语法和语义上非常相似。唯一的区别是驱动条件的表达式唯一可接受的类型是布尔（或宽度为1的正整数，不支持其他宽度正整数）。

可以使用任意嵌套的`if-else if-else`语句。

`if-conditions`可以是任意复杂的表达式，这些表达式被计算为布尔值。

示例：

```cpp
if (Ether.Smac[40:40] == 1) {   //1位字段的测试    
   FwdInfo.DropFlag = true;
}
```

**函数调用语句**

可以使用函数调用语法`()`调用函数。

实参的类型必须与形参类型完全匹配。

@control模块的代码可以调用函数、其他control函数或table。可以查看章节示例模块的ControlFlow函数。Table是NPC++特有的内容，在4.2章节可以查看

示例：

```cpp
void VLAN_OPC_PRI_CFI(uint<1> p_pri, 
                         uint<1> p_cfi, 
                         VLAN_INFO_S p_dst_vlan,
                         VLAN_INFO_S p_src_vlan)  {
    if (p_pri == MODIFY) 
        p_dst_vlan.Pri = p_src_vlan.Pri;
}
//函数调用，跟C语言一样
VLAN_OPC_PRI_CFI(tblRsp.OuterPri, tblRsp.OuterCfi, 
                 NewIVlanInfo,  rsIcib.L2OrVlanifl3.Ovid);
VLAN_OPC_PRI_CFI(tblRsp.InnerPri, tblRsp.InnerCfi, 
                 NewIVlanInfo, rsIcib.Ivid);
```

**return语句**

`return`语句立即终止当前函数的执行

示例：

```cpp
void VLAN_OPC_PRI_CFI(uint<1> p_pri, uint<1> p_cfi)  {
    if (p_pri == MODIFY) 
        p_dst_vlan.Pri = p_src_vlan.Pri;
    else
        return;
        p_dst_vlan.Pri = 1;//由于return语句，此处不再执行
}
```

函数

NPC++的函数都是没有返回值的函数（内置函数除外），其通用格式如下（与C/C++一致

```cpp
void FunctionName(parameterList)
{
    return;
}
```

其中，parameterList指定了传递给函数的参数类型和数量，可选的return标记了函数的结尾，否则函数将在右花括号处结束。不允许递归函数。